clear all 
close all

parpool % remember to turn on
tic 


%% 
% We set the solver tolerance 

ODE_TOL  = 1e-10;
DIFF_INC = sqrt(ODE_TOL);

%% 
% The LHS matrix will sample each parameter over the range of uncertainty 
% with corresponding distribution which is defined by 

Parameter_settings_EFAST_Marino
%% 
% 

runs=50000;
k = size(pmax,1); 
LHSmatrix = zeros(runs, k); 

for i =1 : k 
    LHSmatrix(:,i) = LHS_Call(pmin(i),...
 baseline(i), pmax(i), 0 ,runs,'unif');
end 

%% 
% The matrix will be saved as a csv file to be used later. 

csvwrite('LHS.csv', LHSmatrix); %save LHS matrix

%% 
% When needing to use the matrix, we can call the LHS matrix 

% load parameter set generated by latin hypercube sampling
%parset = dlmread('psets_fullrange');
parset = dlmread('LHS.csv');

%% 
% We will then calculate the sensitivity matrix. For each parameter $x_i$, 
% a local sensitivity measure is calculated based on the parital derivative 
% 
% $$E_i \left(x^* \right)=\frac{\partial f}{\partial x_i }$$
% 
% THe local sensitivity measures $E_i \left(x^* \right)$ depends on a nomial 
% point $x^*$ and it changes with a change of $x^*$. This deficiency can be overcome 
% by averaging repeating $E_i \left(x^* \right)$over the parameter space. 
% 
% We are interested in anlyzing the model output for virus load at a particular 
% time point 

time_points = 2000; 
y_var = 4; 
Nrow = size(parset,1);  % LHS row number     

sens_mat = zeros(Nrow,k); 
sens_rel_mat = sens_mat;


parfor run_num =1:Nrow % make sure to turn on parfor row of LHS 


% sensitivity matrices for changes in parameter and initial conditions
%[sens0, sensR, flagg, y, sol] = senseq(pars,xdata);


 %------------- solve ODE at a nomial value ----------------%  
 f=@ODE_efast_Marino; %myfun;
 opts = odeset('RelTol',ODE_TOL, 'AbsTol',ODE_TOL);
 flagg = 0; 
 Nfail = 0; 
 failSet=[];
 
 try
 [t,y]=ode15s(@(t,y)f(t,y,parset,run_num),tspan,y0,opts);
 catch 
     disp(lasterr);
     flagg=1;  
 end
 
    
if flagg == 0           % check for numerical failure (rare case)
  f0 = y(time_points(1) +1,y_var);
else
  f0 = NaN;   
  failSet = [failSet, run_num];
  Nfail = Nfail+1;
end


for j = 1:k
    
    % for each parameter, slightly perturb its value and evaluate the function 
    epsnew = DIFF_INC;
    
    % parameter delta step = nonzero smallest parameter difference step
    delta_p_vector = sort(abs(diff(parset(:,j))));
    
    id = 1:1:runs-1;
    dp = delta_p_vector(min(id(delta_p_vector~=0))); 
    
    % compare parameter perturbation with parameter step size 
    % if parameter perturbation > step size then redefine perturbation 
    % otherwise, it remains the same 
    
    if epsnew > dp 
        epsnew = dp/2; 
    end 
    
    new_parset = parset(run_num,:); % extract the nomial row of LHS 
    new_parset(j) = new_parset(j)+ epsnew; %perturb x_j value 
    
    flagg = 0; 
    
    try %solve for ODE at nomial value
    [t,y]=ode15s(@(t,y)f(t,y,new_parset,1),...
        tspan,y0,opts);
    catch 
     disp(lasterr);
     flagg=1;  
    end
    
     
    if flagg == 0 % check for numerical failure (rare case)
        f1 = y(time_points(1) +1,y_var);
    else
        f1 = NaN;   
        %failSet = [failSet, run_num];
        Nfail = Nfail+1;
    end
    
    if length(f1) ~= length(f0)
        sens_mat(run_num,j)=0;
        %sens_rel_mat(run_num,j) =0;
    else 
        sens_mat(run_num,j)   = (f1 - f0)/epsnew;
        % %Relative sensitivity = change in glucose/epsilon
        sens_rel_mat(run_num,j) = sens_mat(run_num,j)/f0;
    end
end% j parameter



end %run_num

csvwrite('sens_mat.csv', sens_mat);
csvwrite('sens_rel_mat.csv', sens_rel_mat);


delete(gcp('nocreate'))

elapse = toc;
dlmwrite('derivative_runtime.csv',elapse,'-append')


%% 
%