clear all 
close all

%only get data when a and eL varies to find out the range of uncertainty
parpool % parfor parpool
tic 


%% 
% We set the solver tolerance 

ODE_TOL  = 1e-10;
DIFF_INC = sqrt(ODE_TOL);

%% 
% The LHS matrix will sample each parameter over the range of uncertainty 
% with corresponding distribution which is defined by 

Parameter_settings;
%% 
% 

runs= 200000;
k = size(pmin,1); 

% All other parameters are at its baseline values 
%LHSmatrix = repelem(baseline',runs, 1); 

% except a and eL are varied around range of uncertainty 
for i = 1:k
    LHSmatrix(:,i) = LHS_Call(pmin(i),...
 baseline(i), pmax(i), 0 ,runs,'unif');
end 


%% 
% The matrix will be saved as a csv file to be used later. 

csvwrite('2D_LHS.csv', LHSmatrix); %save LHS matrix

%% 
% When needing to use the matrix, we can call the LHS matrix 

% load parameter set generated by latin hypercube sampling
%parset = dlmread('psets_fullrange');
parset = dlmread('2D_LHS.csv');

y_var = 1; 
Nrow = size(parset,1);  % LHS row number     


Nfail = 0; 


for run_num =1:Nrow %parfor 

f0=0;

% sensitivity matrices for changes in parameter and initial conditions
%[sens0, sensR, flagg, y, sol] = senseq(pars,xdata);

%------------- solve ODE at a nomial value ----------------%  
f=@ligandOde; %myfun;
tf = 25;

opts    = odeset('Events', @complexevent);
[t,y,te,ye,ie]=ode15s(@(t,y)f(t,y,parset,run_num),[0, tf],y0,opts);


%ye contains the solution value when ode solver return complex number  
if isempty(ye)==0
    f0(run_num) = NaN;   
    dlmwrite('2D_failset.csv',run_num,'-append')
    Nfail = Nfail+1;
else 
    f0(run_num) = y(end, y_var); 
end


%dlmwrite('2D_out.csv', f0,'-append');


end %run_num




delete(gcp('nocreate'))

elapse = toc;
save('2D_Derivative_data.mat','Nfail','LHSmatrix');


%% 
%